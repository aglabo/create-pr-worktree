# src: ./.github/actions/pr-worktree-cleanup/action.yml
# @(#) : Composite action to clean up worktree created by pr-worktree-initialize
#
# Copyright (c) 2026- aglabo <https://github.com/aglabo>
#
# This software is released under the MIT License.
# https://opensource.org/licenses/MIT

name: PR Worktree Cleanup
description: Remove a git worktree created by pr-worktree-initialize
author: atsushifx

inputs:
  worktree-dir:
    description: "Directory path of the worktree to remove (optional, auto-detected if not provided)"
    required: false
  base-branch:
    description: "Base branch to exclude from cleanup (optional, auto-detected if not provided)"
    required: false
  force:
    description: "Force removal even if worktree has uncommitted changes"
    required: false
    default: "false"

outputs:
  status:
    description: "Status of cleanup operation (success, skipped, error)"
    value: ${{ steps.get-worktree.outputs.status || steps.validate-worktree.outputs.status || steps.cleanup-worktree.outputs.status }}
  reason:
    description: "Reason for the cleanup result (removed, removed-dirty, no-path, already-removed, multiple, no-worktrees, not-registered, missing-marker, invalid-worktree, uncommitted, git-failed, removal-failed)"
    value: ${{ steps.get-worktree.outputs.reason || steps.validate-worktree.outputs.reason || steps.cleanup-worktree.outputs.reason }}
  message:
    description: "Detailed message about the cleanup operation"
    value: ${{ steps.get-worktree.outputs.message || steps.validate-worktree.outputs.message || steps.cleanup-worktree.outputs.message }}
  removed-path:
    description: "Path of the removed worktree (empty if not removed)"
    value: ${{ steps.get-worktree.outputs.worktree-path }}
  worktree-count:
    description: "Number of worktrees found during auto-detection (0 if not using auto-detection)"
    value: ${{ steps.get-worktree.outputs.worktree-count || '0' }}
  worktree-list:
    description: "List of worktree paths found during auto-detection (empty if not using auto-detection)"
    value: ${{ steps.get-worktree.outputs.worktree-list }}

runs:
  using: composite
  steps:
    - name: Get base branch
      id: get-base-branch
      if: inputs.worktree-dir == ''
      shell: bash
      run: |
        # Priority 1: Explicit input
        BASE_BRANCH="${{ inputs.base-branch }}"

        # Priority 2: GitHub context (PR base or default)
        if [ -z "${BASE_BRANCH}" ]; then
          BASE_BRANCH="${GITHUB_BASE_REF:-main}"
        fi

        # Priority 3: Try detection as last resort (don't fail if it doesn't work)
        if [ "${BASE_BRANCH}" = "main" ]; then
          DETECTED_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")
          if [ -n "${DETECTED_BRANCH}" ]; then
            BASE_BRANCH="${DETECTED_BRANCH}"
          fi
        fi

        echo "Using base branch: ${BASE_BRANCH}"
        echo "base-branch=${BASE_BRANCH}" >> $GITHUB_OUTPUT

    - name: Get worktree path
      id: get-worktree
      shell: bash
      run: |
        WORKTREE_PATH=""
        STATUS=""
        MESSAGE=""
        REASON=""
        WORKTREE_COUNT=0
        WORKTREE_LIST=""

        if [ -n "${{ inputs.worktree-dir }}" ]; then
          # Use provided worktree-dir (recommended)
          WORKTREE_PATH="${{ inputs.worktree-dir }}"
          echo "Using provided worktree path: ${WORKTREE_PATH}"
        else
          # Auto-detect worktree using base branch from previous step (fallback)
          echo "::warning::Auto-detection is a fallback feature. Explicitly specify worktree-dir for production use."
          BASE_BRANCH="${{ steps.get-base-branch.outputs.base-branch }}"
          echo "Auto-detecting worktree (excluding base branch: ${BASE_BRANCH})"

          # Get list of worktrees excluding base branch
          WORKTREE_LIST=$(
            git worktree list --porcelain |
              awk -v base="${BASE_BRANCH}" '
                /^worktree / { path=$2 }
                /^branch / {
                  gsub("refs/heads/", "", $2)
                  if ($2 != base) print path
                }
                '
            )

          # Count worktrees first
          if [ -z "${WORKTREE_LIST}" ]; then
            WORKTREE_COUNT=0
          else
            WORKTREE_COUNT=$(echo "${WORKTREE_LIST}" | wc -l)
          fi

          echo "Found ${WORKTREE_COUNT} worktree(s) excluding base branch"

          # Decide: continue or skip based on count
          if [ "${WORKTREE_COUNT}" -eq 0 ]; then
            echo "::notice::No worktrees found to clean up (excluding base branch: ${BASE_BRANCH})"
            STATUS="skipped"
            REASON="no-worktrees"
            MESSAGE="No worktrees found to clean up (excluding base branch: ${BASE_BRANCH})"
          elif [ "${WORKTREE_COUNT}" -gt 1 ]; then
            echo "::notice::Multiple worktrees found (${WORKTREE_COUNT}), skipping auto-detection. Please specify worktree-dir explicitly."
            echo "Available worktrees:"
            echo "${WORKTREE_LIST}"
            STATUS="skipped"
            REASON="multiple"
            MESSAGE="Multiple worktrees found (${WORKTREE_COUNT}), specify worktree-dir explicitly"
          else
            # Exactly 1 worktree: continue with cleanup
            WORKTREE_PATH="${WORKTREE_LIST}"
            echo "Found worktree at: ${WORKTREE_PATH}"
          fi
        fi

        echo "worktree-path=${WORKTREE_PATH}" >> $GITHUB_OUTPUT
        echo "status=${STATUS}" >> $GITHUB_OUTPUT
        echo "reason=${REASON}" >> $GITHUB_OUTPUT
        echo "message=${MESSAGE}" >> $GITHUB_OUTPUT
        echo "worktree-count=${WORKTREE_COUNT}" >> $GITHUB_OUTPUT
        echo "worktree-list<<EOF" >> $GITHUB_OUTPUT
        echo "${WORKTREE_LIST}" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Validate worktree
      id: validate-worktree
      if: steps.get-worktree.outcome == 'success' && steps.get-worktree.outputs.status != 'skipped'
      shell: bash
      run: |
        WORKTREE_PATH="${{ steps.get-worktree.outputs.worktree-path }}"
        HAS_UNCOMMITTED="false"

        # Check if worktree path is provided
        if [ -z "${WORKTREE_PATH}" ]; then
          echo "status=skipped" >> $GITHUB_OUTPUT
          echo "reason=no-path" >> $GITHUB_OUTPUT
          echo "message=No worktree path specified" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check if directory exists
        if [ ! -d "${WORKTREE_PATH}" ]; then
          echo "::notice::Directory does not exist (already cleaned up): ${WORKTREE_PATH}"
          echo "status=skipped" >> $GITHUB_OUTPUT
          echo "reason=already-removed" >> $GITHUB_OUTPUT
          echo "message=Directory does not exist: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Authoritative check: Is worktree registered?
        if ! git worktree list --porcelain | grep -q "^worktree ${WORKTREE_PATH}$"; then
          echo "::error::Path is not a registered git worktree: ${WORKTREE_PATH}"
          echo "::error::Directory may exist but is not managed by git worktree"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "reason=not-registered" >> $GITHUB_OUTPUT
          echo "message=Path is not a registered git worktree: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Secondary check: Verify .git worktree marker exists
        if [ ! -e "${WORKTREE_PATH}/.git" ]; then
          echo "::error::Directory is missing .git worktree marker: ${WORKTREE_PATH}"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "reason=missing-marker" >> $GITHUB_OUTPUT
          echo "message=Directory is missing .git worktree marker: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi

        # First, validate worktree is valid git repository
        if ! git -C "${WORKTREE_PATH}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          echo "::error::Path is not a valid git working tree: ${WORKTREE_PATH}"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "reason=invalid-worktree" >> $GITHUB_OUTPUT
          echo "message=Path is not a valid git working tree: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Now safe to check for uncommitted changes
        UNCOMMITTED_CHANGES=$(git -C "${WORKTREE_PATH}" status --porcelain 2>&1)
        GIT_STATUS_EXIT=$?

        if [ ${GIT_STATUS_EXIT} -ne 0 ]; then
          echo "::error::Failed to check worktree status: ${WORKTREE_PATH}"
          echo "status=error" >> $GITHUB_OUTPUT
          echo "reason=git-failed" >> $GITHUB_OUTPUT
          echo "message=Failed to check worktree status" >> $GITHUB_OUTPUT
          exit 1
        fi

        if [ -n "${UNCOMMITTED_CHANGES}" ]; then
          HAS_UNCOMMITTED="true"
          if [ "${{ inputs.force }}" = "false" ]; then
            echo "::error::Cannot remove worktree with uncommitted changes (force=false)"
            echo "::error::Changes found:"
            echo "${UNCOMMITTED_CHANGES}"
            echo "::error::Set force=true to override"
            echo "status=error" >> $GITHUB_OUTPUT
            echo "reason=uncommitted" >> $GITHUB_OUTPUT
            echo "message=Cannot remove worktree with uncommitted changes (force=false)" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi

        echo "Validation passed for worktree: ${WORKTREE_PATH}"
        echo "has-uncommitted=${HAS_UNCOMMITTED}" >> $GITHUB_OUTPUT

    - name: Cleanup worktree
      id: cleanup-worktree
      if: |
        steps.get-worktree.outcome == 'success' &&
        steps.get-worktree.outputs.status != 'skipped' &&
        steps.validate-worktree.outcome == 'success'
      shell: bash
      run: |
        WORKTREE_PATH="${{ steps.get-worktree.outputs.worktree-path }}"

        echo "Removing worktree at: ${WORKTREE_PATH}"

        # Build remove command with force flag if needed
        FORCE_FLAG=""
        if [ "${{ inputs.force }}" = "true" ]; then
          FORCE_FLAG="--force"
        fi

        # Execute removal
        if git worktree remove ${FORCE_FLAG} "${WORKTREE_PATH}"; then
          # Determine reason based on whether worktree was dirty
          HAS_UNCOMMITTED="${{ steps.validate-worktree.outputs.has-uncommitted }}"
          if [ "${HAS_UNCOMMITTED}" = "true" ]; then
            REASON="removed-dirty"
          else
            REASON="removed"
          fi

          echo "status=success" >> $GITHUB_OUTPUT
          echo "reason=${REASON}" >> $GITHUB_OUTPUT
          echo "message=Worktree removed successfully: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          echo "âœ“ Removed worktree at: ${WORKTREE_PATH}"
        else
          echo "status=error" >> $GITHUB_OUTPUT
          echo "reason=removal-failed" >> $GITHUB_OUTPUT
          echo "message=Failed to remove worktree: ${WORKTREE_PATH}" >> $GITHUB_OUTPUT
          echo "::error::Failed to remove worktree at: ${WORKTREE_PATH}"
          exit 1
        fi

        exit 0

    - name: Output cleanup results
      if: always()
      shell: bash
      run: |
        STATUS="${{ steps.get-worktree.outputs.status || steps.cleanup-worktree.outputs.status }}"
        MESSAGE="${{ steps.get-worktree.outputs.message || steps.cleanup-worktree.outputs.message }}"
        WORKTREE_PATH="${{ steps.get-worktree.outputs.worktree-path }}"

        echo ""
        echo "=== Worktree Cleanup Complete ==="
        echo "Status: ${STATUS}"

        if [ -n "${MESSAGE}" ]; then
          echo "Message: ${MESSAGE}"
        fi

        if [ "${STATUS}" = "success" ] && [ -n "${WORKTREE_PATH}" ]; then
          echo "Removed Path: ${WORKTREE_PATH}"
        fi
        echo ""
